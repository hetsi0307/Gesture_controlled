<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }



this is my code 
        canvas { display: block; }
        #video-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 150px;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
            opacity: 0.7;
        }
        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror the video */
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            user-select: none;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #00ffff; }
        p { margin: 5px 0; font-size: 0.9rem; }
        .highlight { color: #ff00ff; font-weight: bold; }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-size: 24px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="loading">Initialize Camera & AI...</div>

    <div id="ui">
        <h1>Hand Particle Control</h1>
        <p>üñê <b>Move Hand</b>: Rotate/Move Cloud</p>
        <p>üëå <b>Pinch (Index+Thumb)</b>: Switch Shape</p>
        <p>‚úã <b>Open Palm</b>: Expand / Explode</p>
        <p>‚úä <b>Fist</b>: Condense / Reset</p>
        <p>Current Shape: <span id="shape-name" class="highlight">Sphere</span></p>
    </div>

    <div id="video-container">
        <video id="input-video"></video>
    </div>

    <!-- Import Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 15000;
        const PARTICLE_SIZE = 0.15;
        const PARTICLE_SPEED = 0.08; // Morphing speed

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, particles, geometry, material;
        let positions, targetPositions, colors;
        let clock = new THREE.Clock();
        
        // Interaction State
        const state = {
            shapeIndex: 0,
            isPinching: false,
            isExploding: false,
            handPos: new THREE.Vector3(0, 0, 0),
            lastPinchTime: 0
        };

        const shapes = ['Sphere', 'Heart', 'Saturn', 'Flower', 'Torus'];

        // --- INIT THREE.JS ---
        function initThree() {
            scene = new THREE.Scene();
            // Add subtle fog for depth
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            createParticles();
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- PARTICLE SYSTEM ---
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);

            const colorObj = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Initial: Random Sphere
                const [x, y, z] = getSpherePoint(10);
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                targetPositions[i * 3] = x;
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = z;

                // Initial Color: Cyan/Blue mix
                colorObj.setHSL(0.5 + Math.random() * 0.2, 0.8, 0.5);
                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Custom texture for particle softness
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                map: sprite,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- SHAPE GENERATORS (MATH) ---
        
        // 1. Random Sphere
        function getSpherePoint(radius) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = Math.cbrt(Math.random()) * radius; // Volume filling
            return [
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            ];
        }

        // 2. Heart
        function getHeartPoint() {
            // Parametric Heart
            let t = Math.random() * Math.PI * 2;
            let u = Math.random(); // Fill factor
            
            // X = 16sin^3(t)
            // Y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
            
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            
            // Add Z depth based on X/Y to make it 3D puffy
            const zScale = (1 - Math.abs(t / Math.PI - 1)) * 4; 
            const z = (Math.random() - 0.5) * zScale * 2; 

            const scale = 0.5;
            return [x * scale, y * scale, z * scale];
        }

        // 3. Saturn
        function getSaturnPoint() {
            const isRing = Math.random() > 0.6; // 40% planet, 60% ring
            
            if (isRing) {
                const angle = Math.random() * Math.PI * 2;
                const r = 12 + Math.random() * 8; // Ring radius
                return [
                    Math.cos(angle) * r,
                    (Math.random() - 0.5) * 0.5, // Thin height
                    Math.sin(angle) * r
                ];
            } else {
                // Planet
                const [x,y,z] = getSpherePoint(6);
                return [x, y, z];
            }
        }

        // 4. Flower
        function getFlowerPoint() {
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI;
            const k = 4; // Number of petals
            
            // Modulate radius based on angle
            const r = 8 + 4 * Math.cos(k * u) * Math.sin(v);
            
            return [
                r * Math.sin(v) * Math.cos(u),
                r * Math.sin(v) * Math.sin(u),
                r * Math.cos(v)
            ];
        }

        // 5. Torus (Donut)
        function getTorusPoint() {
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI * 2;
            const R = 10; // Main radius
            const r = 3;  // Tube radius
            
            return [
                (R + r * Math.cos(v)) * Math.cos(u),
                (R + r * Math.cos(v)) * Math.sin(u),
                r * Math.sin(v)
            ];
        }

        // --- TRANSITION LOGIC ---
        function setShape(shapeName) {
            document.getElementById('shape-name').innerText = shapeName;
            
            let posFunc;
            let hueBase;

            switch(shapeName) {
                case 'Sphere': posFunc = () => getSpherePoint(10); hueBase = 0.5; break;
                case 'Heart': posFunc = getHeartPoint; hueBase = 0.0; break; // Red
                case 'Saturn': posFunc = getSaturnPoint; hueBase = 0.1; break; // Orange
                case 'Flower': posFunc = getFlowerPoint; hueBase = 0.8; break; // Pink/Magenta
                case 'Torus': posFunc = getTorusPoint; hueBase = 0.3; break; // Green
                default: posFunc = () => getSpherePoint(10); hueBase = 0.5;
            }

            const colorObj = new THREE.Color();
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const [tx, ty, tz] = posFunc();
                targetPositions[i * 3] = tx;
                targetPositions[i * 3 + 1] = ty;
                targetPositions[i * 3 + 2] = tz;

                // Update target color (store in a temp way, simpler to direct lerp later but here we reset)
                // For a cooler effect, we vary the hue slightly per particle
                colorObj.setHSL(hueBase + Math.random() * 0.1, 0.8, 0.5);
                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;
            }
            
            geometry.attributes.color.needsUpdate = true;
        }

        function triggerNextShape() {
            const now = Date.now();
            if (now - state.lastPinchTime > 1000) { // 1 second cooldown
                state.shapeIndex = (state.shapeIndex + 1) % shapes.length;
                setShape(shapes[state.shapeIndex]);
                state.lastPinchTime = now;
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const positionsArray = geometry.attributes.position.array;

            // Map hand input to rotation/offset
            // Smoothly interpolate camera/particle rotation based on hand X/Y
            particles.rotation.y += 0.002; // Idle spin
            
            // Interactive rotation based on hand X
            const targetRotX = (state.handPos.y * 2); // Tilt
            const targetRotY = (state.handPos.x * 2); // Pan
            
            particles.rotation.x += (targetRotX - particles.rotation.x) * 0.05;
            particles.rotation.y += (targetRotY - particles.rotation.y) * 0.05;

            // Update individual particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let tx = targetPositions[ix];
                let ty = targetPositions[iy];
                let tz = targetPositions[iz];

                // Explosion logic (Open Hand)
                if (state.isExploding) {
                    tx *= 2.5;
                    ty *= 2.5;
                    tz *= 2.5;
                }

                // Move current pos towards target pos (Lerp)
                positionsArray[ix] += (tx - positionsArray[ix]) * PARTICLE_SPEED;
                positionsArray[iy] += (ty - positionsArray[iy]) * PARTICLE_SPEED;
                positionsArray[iz] += (tz - positionsArray[iz]) * PARTICLE_SPEED;

                // Add some noise/jitter for "aliveness"
                if (!state.isExploding) {
                    positionsArray[ix] += Math.sin(time + positionsArray[iy]) * 0.02;
                    positionsArray[iy] += Math.cos(time + positionsArray[ix]) * 0.02;
                }
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MEDIAPIPE HAND TRACKING ---
        const videoElement = document.getElementById('input-video');

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // 1. Get Coordinates (Normalized 0-1)
                // Invert X because video is mirrored
                const palmX = 1.0 - landmarks[9].x; 
                const palmY = landmarks[9].y;

                // Map to Three.js World Space (roughly -1 to 1)
                state.handPos.set((palmX - 0.5) * 2, (0.5 - palmY) * 2, 0);

                // 2. Gesture Detection
                
                // Pinch Detection (Thumb Tip to Index Tip)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                
                if (pinchDist < 0.05) {
                    if (!state.isPinching) {
                        triggerNextShape();
                        state.isPinching = true;
                    }
                } else {
                    state.isPinching = false;
                }

                // Open Hand / Explosion Detection
                // Distance from wrist (0) to Middle Finger Tip (12)
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const handSpan = Math.hypot(wrist.x - middleTip.x, wrist.y - middleTip.y);

                // If hand is very open (large span)
                if (handSpan > 0.45) { // Threshold might need tuning based on camera distance
                    state.isExploding = true;
                } else {
                    state.isExploding = false;
                }

            } else {
                // No hand detected, reset slightly
                state.isExploding = false;
                state.handPos.set(0,0,0);
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // Start
        initThree();
        animate();

    </script>
</body>
</html>
